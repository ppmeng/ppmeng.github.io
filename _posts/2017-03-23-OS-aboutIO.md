---
title: "关于IO模型"
categories: "操作系统"
tags: ["OS", "IO", "同步", "异步", "阻塞", "非阻塞"]
---

## IO
1. IO是input和output的简写，直观理解就是输入输出，也就是数据的流动，很明显对于不同的主体输入输出就有不同的定义

- 直观理解的话，IO是计算机和外部设备之间的数据流动，主体是计算机主机，那么键盘就属于输入设备，屏幕就属于输出设备
- 也可以理解为是计算机核心（cpu和内存）与其他设备之间的数据流动，本体就是计算机核心，那么将数据从内存写入硬盘就是输出
- 从编程的角度讲的话，IO的主体是程序的运行态——进程，IO也就是进程内部数据和外部数据之间的流动，这里我们主要讨论的就是这一种。这里需要明确一点，其实IO操作不仅仅是进程自己完成的，进程只是IO调用的主体，真正IO操作的执行还需要操作系统的帮忙,所以准确来说，这里所说的IO仅仅是进程对操作系统IO功能的调用

2. linux对IO文件的操作分为缓存IO（BufferIO）和直接IO（DirectIO）。
- 缓存IO又被称为是标准IO，大多数文件系统默认的IO操作就是缓存IO。在linux的IO机制中，操作系统会将IO的数据缓存到文件系统的页缓存（page cache）中，也就是说，数据会先从磁盘copy到操作系统内核的缓冲区中，然后再copy到进程的地址空间
- 直接IO就是进程直接访问磁盘数据，不经过内核缓冲区。


## 同步和异步 阻塞和非阻塞
 - 同步和异步关注的是消息通知机制。同步指的是，发出调用之后，调用结果和调用函数的返回值一起返回；异步指的是，发出调用之后，调用函数就直接返回了，但是调用结果没有返回。也就是说，一个同步调用发出之后，无论成功还是失败，调用者都能在调用函数结束后立马知道调用结果，但是异步调用结束后，调用者却不知道调用结果，只能被动等待通过一些状态、通知或调用函数之类的被动得到调用结果
 - 阻塞和非阻塞关注的是等待调用结果的过程中的进程状态。阻塞指的是，发出调用之后，在设备没有就绪或者数据没有到达内核缓冲区的时候，阻塞IO的进程状态会切换为S，进程被挂起，非阻塞IO的进程会立刻返回错误

## linux IO模型
参考缓存IO，对于一次IO访问，数据会被先copy到内核缓冲区，然后再从内核缓冲区copy到进程的地址空间，所以对于一次read，他会经历两个阶段：
1. 等待数据准备
2. 将数据从内核copy到进程中

根据这两个阶段内进程的状态，linux中将IO模型分为以下五种

### 同步阻塞IO模型
同步阻塞IO特点是进程执行一个read操作后，直到数据返回，进程一直都会被阻塞，让出CPU，不能处理别的IO。具体过程如下：

- 第一阶段：准备数据。此时对于网络IO来说，很多时候数据还没有到达，比如还没有收到UDP包，这时候就需要一直等待，在用户进程这边，进程会被阻塞，即进程暂时被挂起，让出CPU，直到数据准备好，
- 第二个阶段：数据准备好之后从内核复制到用户进程地址空间，然后内核返回结果，用户进程才会解除阻塞状态，处理数据


**优点：**
1. 符合人的逻辑思维，开发比较简单
2. 及时返回数据，没有延迟，适合实时系统
3. 在希望能够立即发送和接收数据并且需要处理socket数量比较少的时候可以选择阻塞IO
**缺点：**
1. 对于需要处理socket数量较多的情况下不适合，扩展性能差

### 同步非阻塞IO模型
同步非阻塞IO特点是进程发出read操作之后需要不断地主动询问数据准备好了没有。具体就是：

- 第一个阶段：准备数据。在这个阶段，从用户进程的角度讲，它发起一个read操作，不需等待马上就可以得到结果，假如数据没有准备好，结果就是一个error。用户进程轮询结果，直到数据准备好
- 第二阶段：数据从内核复制到用户进程空间。当数据准备好之后并且又再次收到用户进程的read，就立刻将数据复制到用户进程地址空间，然后返回成功指示

**优点：**
1. 准备数据的时候用户进程不会被阻塞，也就意味着可以在数据准备的过程中可以处理别的任务
**缺点：**
1. 数据返回有延迟，因为每过一段时间才进行一次read操作，而数据可能在两次轮询之间的任意时间完成
2. 轮询会消耗大量的CPU时间，会导致整体数据吞吐量的降低

### IO多路复用模型
IO多路复用特点是单个进程可以同时处理多个网络IO。这个模型会用到select、poll、epoll这些调用函数，他们都是内核级别的，但是和阻塞IO相比差别是，这些函数可以同时阻塞多个IO操作。和非阻塞IO的轮询相比，用户进程可以等待多个socket，同时处理多个网络io，但是用户进程不是等待全部socket数据到达之后再处理，而是只要有一部分到达就会调用用户进程来处理。具体如下：

- 第一个阶段：准备数据。当用户进程调用了select，那么整个进程就会被阻塞，同时，内核会监听所有select负责的socket，当有任何一个socket数据准备好了，select就会返回，
- 第二个阶段：复制数据到用户进程。select返回后，进程再进行系统调用，将数据从内核复制到用户进程

**优点：**
1. 系统在单线程的情况下也可以同时处理多个网络io，与多线程相比不需要维护额外的线程运行，系统开销小
2. 适合服务器需要同时处理多个处于监听状态或者连接状态的socket；适合服务器需要同时处理多种网络协议的socket
**缺点：**
1. 用了两个系统调用，这样的话在网络连接数不是特别多的情况下，使用这个模型的web server可能还没有使用多线程+阻塞IO性能好

### 信号驱动IO模型
这个模型用的比较少，特点是进程预先告诉内核，当某个描述符发生某件事时使用信号通知进程

- 第一阶段：准备数据。首先用户进程会建立SIGIO的信号处理程序，进程不会被阻塞，等到数据到达内核或者socket发生异常错误的时候收到一个信号。
- 第二阶段：复制数据到用户进程或者捕获错误。收到信号后进程进行系统调用将数据复制到自己的地址空间或者获取发生的异常

### 异步IO模型
这个模型主要特点是用户进程不关系数据什么时候到达内核且一直都是非阻塞的。

- 第一个阶段:准备数据。用户进程进行aio_read系统调用之后，无论内核是否准备好数据，调用都会直接返回，然后用户进程可以去做别的事情
- 第二个阶段：复制数据到用户进程。当数据到达内核之后，内核会直接将数据复制给用户进程，然后内核使用某个特定信号或者执行一个 通知用户进程

**优点：**
1. 对用户而言更省事，cpu利用率高
**缺点：**
1. 很多系统不支持，而且linux系统的异步最初是为了数据库设计，所以不会被缓冲，也就没办法利用操作系统的缓冲机制
2. 对开发者而言更加复杂，需要考虑数据复制好之后通知用户进程时用户进程的状态（进程在用户态处理任务——强行打断调用实现注册的信号处理函数决定何时以及如何处理这个任务；进程在内核态处理事情——通知挂起等进程回到用户态；进程被挂起——唤醒）